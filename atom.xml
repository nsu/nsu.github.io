<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Electric Garbage]]></title>
  <link href="http://blog.alexkarpinski.com/atom.xml" rel="self"/>
  <link href="http://blog.alexkarpinski.com/"/>
  <updated>2013-07-13T19:32:34-04:00</updated>
  <id>http://blog.alexkarpinski.com/</id>
  <author>
    <name><![CDATA[Alex Karpinski]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Devops on an iPad]]></title>
    <link href="http://blog.alexkarpinski.com/blog/2013/07/10/devops-on-an-ipad/"/>
    <updated>2013-07-10T00:36:00-04:00</updated>
    <id>http://blog.alexkarpinski.com/blog/2013/07/10/devops-on-an-ipad</id>
    <content type="html"><![CDATA[<p>When I started software development I worked pretty much exclusively on my
personal notebook, in my lap. I ended up migrating to a pretty standard
workstation by 2011.</p>

<p>Combining a <a href="http://www.hengedocks.com/">Henge Dock</a> with a pretty heavily upgraded
13&#8221; Macbook Pro, and a <a href="http://pckeyboard.com/page/UKBD/UB40P4A">Unicomp Classic</a>,
gave me a really nice, capable work environment. Coupling that with a big home
next room with kernel-based virtual machines made for carefree testing.</p>

<p>This setup gave me a ton of flexibility and the freedom
to work on static websites, web applications, and devops configurations with
little to no interruption or reconfiguration. If you like having a conventional
desktop workstation, I can highly recommend this style.</p>

<p>When I started working for Sudo in early 2013, I shifted from a role of combined
operations and development, to full-time operations engineering. This meant that
most of my time was spent SSH\&rsquo;d into other servers, and what time wasn&rsquo;t spend
there, was spent in the Amazon Web Services console.</p>

<p>Also I had to go to an office. On this.</p>

<p><img class="center" src="http://blog.alexkarpinski.com/images/giant_escape.png" width="350" height="350" title="image" alt="images"></p>

<p>Taking in a laptop every day with the possibility of accidents and rain wasn&rsquo;t
appealing to me. Add to that the weight of a laptop, and I wasn&rsquo;t looking
forward to my commute.</p>

<p>I&rsquo;ve never really gotten the point of tablets. That&rsquo;s not to say I think they&rsquo;re
bad, but I never had any urge to buy one. Faced with my new commute and a new
job, they were suddenly starting to look appealing.</p>

<p>I was already spending all of my time in a single application anyway. If all I
needed was Terminal and a bit of Chrome on my laptop, why should it be any
different on the iPad? Full screen terminals are a perfect work environment, and
that translates to the tablet ecosystem better than a whole lot of other tasks
that have ended up on there.</p>

<p>As long as I could get a half-decent terminal emulator and SSH client on an
iPad, I could hook it up an an EC2 instance inside Sudo&rsquo;s VPC and be right back
to work.</p>

<p>NOTE: I really wanted to make this work on a Microsoft Surface RT, but the
software just wasn&rsquo;t ready.</p>

<p>Now I bike to work with an iPad on the back of my bike.</p>

<p><img class="center" src="http://blog.alexkarpinski.com/images/ipad-panniers.png" width="350" height="350" title="image" alt="images"></p>

<p>It&rsquo;s way lighter, way harder to break, and a lot less to lose if it gets stolen.
Coupled with the fantastic <a href="http://www.moshimonde.com/product/iglaze-with-versacover.aspx">Moshi Versacover</a>,
a bluetooth keyboard, and <a href="http://www.zinger-soft.com/iSSH_features.html">iSSH</a>
you actually end up with a pretty capable development machine.</p>

<p>Unless you need the AWS Console.</p>

<p>If you need the AWS Web Console You&rsquo;re going to have a terrible time with this
setup. I had to entirely abandon the web interface for AWS when working from my
iPad. It&rsquo;s sluggish at best, dangerous at worst. Most of the time it just takes
forever to load anything, and once it has, good luck interacting with it.
Often, Safari (or Chrome, or Opera) will simply crash when trying to load a new
interface component. If you&rsquo;re really unlucky your impatient taps will finally
get registeres after two or three minutes of waiting, only to incorrectly
configure a new load balancer of Route53 record.</p>

<p>When it comes to AWS, use the <a href="https://aws.amazon.com/cli/">CLI tools</a>, or one
of the SDKs. I&rsquo;ve used both <a href="https://aws.amazon.com/sdkforruby/">Ruby&rsquo;s aws-sdk</a>
and <a href="https://aws.amazon.com/sdkforpython/">Python&rsquo;s boto</a> and both are
fantastic.</p>

<p>The bottom line is that the iPad can be a great alternative to a conventional
desktop workstation, but it takes some serious getting used to, and has some
real limitations.</p>

<h2>More</h2>

<p>If you&rsquo;re interested in the idea, I really recommend checking out these links.</p>

<ul>
<li><a href="http://yieldthought.com/post/12239282034/swapped-my-macbook-for-an-ipad">I swapped my MacBook for an iPad+Linode</a></li>
<li><a href="http://yieldthought.com/post/31857050698/ipad-linode-1-year-later">iPad + Linode, 1 Year Later</a></li>
<li><a href="http://thebinaryapp.com/">Binary &ndash; Development Environment for iPad</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[High availability postgres on AWS: The Problem]]></title>
    <link href="http://blog.alexkarpinski.com/blog/2013/06/30/high-availability-postgres-on-aws/"/>
    <updated>2013-06-30T00:00:00-04:00</updated>
    <id>http://blog.alexkarpinski.com/blog/2013/06/30/high-availability-postgres-on-aws</id>
    <content type="html"><![CDATA[<p>At <a href="http://gosudo.com">Sudo</a> we use Postgres for our database backend. Postgres
is a fantastic database that provides a lot of functionality and stability over
MySQL (and if you really want to use MySQL, you should use
<a href="http://mariadb.org/">MariaDB</a> instead). However, there is one big caveat:
AWS doesn&rsquo;t support Postgres for RDS yet. This means that if you want high
availability and scalability with Postgres, you&rsquo;re going to have to implement
your own solution.</p>

<p>There are things like <a href="http://www.cloudpostgres.com/">Cloud Postgres</a> out there, but
they don&rsquo;t provide anything like the power of RDS. Ideally, if you&rsquo;re running
your application on AWS, you should try to use RDS. That means using MySQL,
OracleDB or MSSQL, if at all possible, and saying goodbye to  Postgres until Amazon
integrates it into RDS. This will give you easy access to to performance and
reliability. You really can&rsquo;t beat it.</p>

<p><img class="center" src="http://blog.alexkarpinski.com/images/yourproblem.png" width="350" height="350" title="image" alt="images"></p>

<p style="text-align:center;"> <em>Your Problem</em></p>

<p><img class="center" src="http://blog.alexkarpinski.com/images/notyourproblem.png" width="350" height="350" title="image" alt="images"></p>

<p style="text-align:center;"> <em>Not Your Problem</em></p>

<p>However, if you&rsquo;re like Sudo, you don&rsquo;t really have that choice. We use location
data extensively for to help users find deals near them, and that means we need
a location-aware DB. Check out
<a href="http://www.bostongis.com/PrinterFriendly.aspx?content_name=sqlserver2008_postgis_mysql_compare">these tables</a>
for a good comparison of the available location-aware databases. Then compare that with
<a href="https://docs.djangoproject.com/en/dev/ref/databases/#using-a-3rd-party-database-backend">Django&rsquo;s ORM compatability</a>
and compare all of that to <a href="https://docs.djangoproject.com/en/dev/ref/contrib/gis/db-api/">GeoDjango&rsquo;s compatible database
backends</a></p>

<p>The result is that we&rsquo;re pretty much stuck with Postgres, and that means
we have toroll our own database infrastructure.</p>

<h2>What Do We Want?</h2>

<p>So our requirements are something like this (and in this order)</p>

<ol>
<li>Support location data</li>
<li>Support Django</li>
<li>Provide high availability</li>
<li>Provide scaling capacity</li>
</ol>


<p>Just by picking Postgres+PostGIS we get #1 an #2, literally for free. If you&rsquo;re
curious how easy it is to set up a location aware Postgres database with Django,
well, <a href="https://docs.djangoproject.com/en/dev/ref/contrib/gis/install/postgis/">It&rsquo;s not that easy, but it&rsquo;s not that
hard either</a></p>

<p>Getting the last two problems solved is a lot harder than the first two, though,
and it&rsquo;s probably worthwhile to at least examine the basic reasons you might
want each.</p>

<p>If you&rsquo;re comfortable with operations engineering, you can probably skip this
next bit safely.</p>

<h3>High Availability</h3>

<p>Any sysadmin should crave uptime. Ideally no part of your
infrastructure should be a single point of failure for your application. This
means clustering, failover, replication, and more. The goal should be not just
to keep your application from going offline, but to keep you and your team
from having to rescue or rebuild it by hand. Ideally, a database server could
go down and the rest of your cluster could recover without going offline. Better
yet, a replacement server could be automatically provisioned, and joined to the
cluster to replace the broken node. If you can set this up across all
availability zones in an AWS region, and you get a database cluster that&rsquo;s very
hard to take down without an act of God (or a very mistaken sysadmin).</p>

<p>The fast pace of modern development, taken together with the complicated systems
that they leverage means that things will inevitably break. High availability
architecture ensures that a single server failing doesn&rsquo;t cause any serious
damage or downtime to your application.</p>

<p>This is equally good for developers and users. For operations engineers, this
means no 3am calls from Nagios requiring you to manually repair a database.</p>

<p>For users, it means the application is always ready for them whenever they want
it.</p>

<p><img class="center" src="http://blog.alexkarpinski.com/images/reddit.png" width="350" height="350" title="image" alt="images"></p>

<p style="text-align:center;"> Avoid this</p>

<h3>High Scalability</h3>

<p>While Sudo doesn&rsquo;t need the sort of performance that apps like Instagram or
Pinterest use AWS to achieve, we don&rsquo;t want to be locked into a low-performance
solution for our database, just because it fit our needs early on.</p>

<p>The goal here is to build a database layer that can increase and decrease in
performance in order to best fit our needs at any given time. This
means that not only should we have the ability to easily scale our database
to respond to increases in user demand, but we should also be able to decrease
during lulls in order to minimize cost.</p>

<h2>What&rsquo;s Next?</h2>

<p>There are a number of ways to solve this problem. At Sudo we use
<a href="http://www.opscode.com/chef/">Chef</a> for automated deployment, so any solution
we create will be implemented through it. If you&rsquo;re interested in some of the
possible ways to go about building a solution, check out <a href="#">part two</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Initial commit]]></title>
    <link href="http://blog.alexkarpinski.com/blog/2013/06/29/initial-commit/"/>
    <updated>2013-06-29T23:44:00-04:00</updated>
    <id>http://blog.alexkarpinski.com/blog/2013/06/29/initial-commit</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
